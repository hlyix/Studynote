# Chapter 1 Mysql架构与历史
## 1.1 Mysql的逻辑架构
分为三层：
1. 最上层大多数是基于网络的客户端/服务器的工具或者服务都有类似的架构。
2. 第二层包含了大多数Mysql的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数。所有跨储存引擎的功能都在这一层实现：存储过程、触发器、视图等。
3. 第三层就包含了存储引擎。

### 1.1.1 连接管理和安全性
 Mysql服务器在每个客户端连接进来时都会为其创建一个线程，该线程只能轮流在某个CPU核心或者CPU内运行，Mysql服务器会缓存这些线程（线程池），节约创建和销毁线程的时间。
 当客户端连接到Mysql服务器时，服务器需要对其进行认证。认证基于用户名、原始主机的信息和密码。如果使用了安全套接字（SSL）的连接方式，还可以使用X.509证书认证。一旦客户端连接成功，服务器会继续验证该客户端是否具有某个特定查询的权限。

### 1.1.2 优化和执行
Mysql会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。（第6章）
优化器并不关心表使用的时什么存储引擎。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。（第4章和第5章）
对于select语句，在解析之前服务器会先检查查询缓存，如果能在缓存中找到对应的查询结果，服务器就不必再执行查询解析、优化和执行的整个过程。

## 1.2 并发控制
### 1.2.1 读写锁
主要分为两种锁，一种时共享锁（也叫读锁），一种是排他锁（也叫写锁）
- 读锁：是共享的，或者说是互相不阻塞的。多个客户再统一时刻可以同时读取同一个资源，而互不干扰。
- 写锁：是排他的，也就是说一个写锁可以阻塞其他的写锁和读锁，可以确保再给定的时间力，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

### 1.2.2 锁粒度
- 表锁
表锁是开销最小的策略，他会锁定整张表，阻塞其他所有用户对该表的读写操作。
- 行级锁
行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。在InnoDB和XtraDB等引擎中实现了行级锁。行级锁旨在存储引擎层实现，而Mysql服务层没有实现。

## 1.3 事务
一个事务，要么全部执行改组查询，只要其中一个失败那就都不执行。
可以使用START TRANSACTION语句开始一个事务，然后要么使用COMMIT提交事务将修改的数据永久保存，要么用ROLLBACK撤销所有的修改：
```
START TRANSACTION
SELECT balance FROM checking WHERE customer_id = 10233276;
UPDATE checkings SET balance = balance - 200.00 WHERE customer_id = 10233276;
UPDATE savings SET balance = balance + 200.00 WHERE customer_id = 10233276;
COMMIT;
```

事务的ACID四个属性：
1、原子性
一个事物要么全部执行要么全部不执行
2、一致性
数据库总是从一个一致状态转换到另一个一致性状态（例如转账时银行账户总金额是不变的）
3、隔离性
