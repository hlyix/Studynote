# epoll的理解与应用

## 再谈select
### select的I/O复用速度慢的原因
主要分为一下两点：
1. 每次调用select函数后常见的对所有文件描述符的循环语句
2. 每次调用select函数时都需要向该函数传递监视对象信息

以上两点中，第二点的影响是最为巨大的，for循环好歹能够通过程序层面进行优化。而==每次调用select函数时向操作系统传递监视对象信息==！无法通过代码优化解决。

select也有优点，以下情况就可以不拘泥于select还是epoll：
1. 服务器端介入少者
2. 程序具有兼容性

## epoll的出现
epoll祢补了select的缺点，==它可以仅仅向操作系统传递1次监视对象，监视范围或内容发生变化时才只通知发生变化的事项。== 这样就无需每次调用监视函数的时候都向操作系统传递监视对象信息。

epoll优点主要是以下两点：
1. 无需编写以监视状态变化为目的的针对所有文件描述符的循环语句
2. 调用对应于select函数的epoll_wait函数时无需每次传递监视对象信息

### epoll使用介绍

- epoll服务器中需要的三个函数：
`epoll_create`:创建保存epoll文件描述符的空间
`epoll_ctl`:向空间注册并注销文件描述符
`epoll_wait`: 与select函数类似，等待文件描述符发生变化。

注意与select不用，select用fd_set保存监视对象的fd，而epoll直接用epoll_create向系统请求创建保存文件描述符的空间，这些被监视的fd由操作系统保存。

epol通过epoll_event将发生变化的文件描述符单独集中到一起
```
struct epoll_event
{
  __uint32_t events; //要监视的事件
  epoll_data_t data; //记录了文件描述符fd等信息
}
```
```
typedef union epoll_data
{
  void * ptr;
  int fd; // 监视的文件描述符
  __uint32_t u32;
  __uint64_t u64;
}epoll_data_t;
```


