# send&recv函数
## 基本介绍
send和recv与write和read基本上相同，只是后缀多了一个flags的可选信息，以及结构体的声明不相同。
```
#include<sys/socket.h>
ssize_t send(int sockfd, const void* buf, size_t nbytes, int flags);

ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags);
```
`sockfd`:传输数据的套接字文件描述符
`buf`：保持文件待传输数据的缓冲地址值
`nbytes`:待传输的字节数
`flags`：传输时可选的信息

关于send&recv的第四个参数flags的可选项及含义
|可选项（Option）|含义|send|recv|
|--|--|--|--|
|MSG_OOB|用于传输带外数据（紧急消息）|√|√|
|MSG_PEEK|验证输入缓存中是否存在接收的数据|×|√|
|MSG_DONTROUTE|数据传输过程中不参照路由表，在本地网络中寻找目的地|√|×|
|MSG_DONTWAIT|调用I/O函数时不阻塞,用于使用非阻塞I/O|√|√|
|MSG_WAITALL|防止函数返回，直到收到全部请求的字节数|×|√|

## MSG_OOB(发送紧急消息)
```
send(sock, "4", strlen("4"), MSG_OOB);//发送紧急信息
recv(recv_sock, buf, sizeof(buf)-1, MSG_OOB);//接收紧急信息

fcntl(recv_sock,F_SETOWN,getpid());
//将收到的紧急消息交由此接收消息的进程处理这个信号，也就是让此进程调用处理函数。

```
但是千万不要误解了MSG_OOB，因为它只能告诉程序员